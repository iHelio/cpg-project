%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#e3f2fd'}}}%%
sequenceDiagram
    autonumber
    participant Client
    participant Orchestrator as ProcessOrchestrator
    participant CtxAssembler as ContextAssembler
    participant EligEval as EligibilityEvaluator
    participant NavDecider as NavigationDecider
    participant Governor as ExecutionGovernor
    participant Tracer as DecisionTracer
    participant Engine as ProcessExecutionEngine
    participant NodeEval as NodeEvaluator
    participant EdgeEval as EdgeEvaluator
    participant ExprEval as ExpressionEvaluator
    participant PolicyEval as PolicyEvaluator
    participant RuleEval as RuleEvaluator
    participant ActionHandler
    participant EventPub as EventPublisher
    participant Instance as ProcessInstance

    rect rgb(232, 245, 233)
        Note over Client,Instance: Orchestrated Process Start
        Client->>Orchestrator: start(graph, runtimeContext)
        Orchestrator->>Instance: create new instance
        Orchestrator->>Instance: save initial state

        Orchestrator->>CtxAssembler: assemble(instance, tenantId)
        CtxAssembler-->>Orchestrator: RuntimeContext

        Orchestrator->>EligEval: evaluateEntryNodes(graph, context)
        EligEval->>NodeEval: evaluate(entryNode, context)
        NodeEval->>ExprEval: evaluateAllAsBoolean(preconditions)
        NodeEval->>PolicyEval: evaluateAll(policyGates)
        NodeEval-->>EligEval: NodeEvaluation
        EligEval-->>Orchestrator: EligibleSpace

        Orchestrator->>NavDecider: select(eligibleSpace, instance, graph)
        NavDecider-->>Orchestrator: NavigationDecision(PROCEED)

        Orchestrator->>Governor: enforce(instance, node, context)
        Governor->>Governor: checkIdempotency()
        Governor->>Governor: checkAuthorization()
        Governor->>Governor: checkPolicyGate()
        Governor-->>Orchestrator: GovernanceResult(approved)

        Orchestrator->>Engine: executeNode(instance, graph, node)
        Engine->>ActionHandler: execute(actionContext)
        ActionHandler-->>Engine: ActionResult(success)
        Engine-->>Orchestrator: NodeExecutionResult

        Orchestrator->>Tracer: record(decisionTrace)
        Orchestrator->>EventPub: publish(process.started)
        Orchestrator-->>Client: ProcessInstance
    end

    rect rgb(227, 242, 253)
        Note over Client,Instance: Orchestration Loop (Event-Driven)
        Client->>Orchestrator: signal(OrchestrationEvent)
        Orchestrator->>Orchestrator: queue event

        loop Event Loop
            Orchestrator->>Orchestrator: poll event from queue

            Orchestrator->>CtxAssembler: assemble(instance, tenantId)
            CtxAssembler->>Instance: getContext()
            CtxAssembler-->>Orchestrator: RuntimeContext (rebuilt)

            Orchestrator->>EligEval: evaluate(instance, graph, context)

            rect rgb(240, 248, 255)
                Note over EligEval,EdgeEval: Build Eligible Space
                EligEval->>NodeEval: evaluate each candidate node
                NodeEval->>ExprEval: evaluate preconditions
                NodeEval->>PolicyEval: evaluate policy gates
                NodeEval->>RuleEval: evaluate business rules
                NodeEval-->>EligEval: NodeEvaluation[]

                EligEval->>EdgeEval: evaluate outbound edges
                EdgeEval->>ExprEval: evaluate guard conditions
                EdgeEval-->>EligEval: EdgeEvaluation[]
                EligEval-->>Orchestrator: EligibleSpace
            end

            Orchestrator->>NavDecider: select(eligibleSpace, instance, graph)

            alt Eligible actions available
                NavDecider->>NavDecider: check exclusive edges
                NavDecider->>NavDecider: apply priority ordering
                NavDecider->>NavDecider: check concurrency semantics
                NavDecider->>NavDecider: record alternatives considered
                NavDecider-->>Orchestrator: NavigationDecision(PROCEED, selectedNodes)

                Orchestrator->>Governor: enforce(instance, node, context)

                alt Governance approved
                    Governor-->>Orchestrator: GovernanceResult(approved)
                    Orchestrator->>Engine: executeNode(instance, graph, node)
                    Engine->>ActionHandler: execute(actionContext)
                    ActionHandler-->>Engine: ActionResult
                    Engine-->>Orchestrator: NodeExecutionResult
                    Orchestrator->>Instance: updateContext(result)
                    Orchestrator->>Tracer: record(decisionTrace: EXECUTION)
                else Governance rejected
                    Governor-->>Orchestrator: GovernanceResult(rejected, reason)
                    Orchestrator->>Tracer: record(decisionTrace: BLOCKED)
                end

            else No eligible actions
                NavDecider-->>Orchestrator: NavigationDecision(WAIT)
                Orchestrator->>Tracer: record(decisionTrace: WAIT)
            end
        end
    end

    rect rgb(255, 243, 224)
        Note over Client,Instance: Resume After Suspend
        Client->>Orchestrator: resume(instanceId)
        Orchestrator->>Instance: resume()

        Orchestrator->>CtxAssembler: assemble(instance, tenantId)
        CtxAssembler-->>Orchestrator: RuntimeContext

        Orchestrator->>EligEval: evaluate(instance, graph, context)
        EligEval-->>Orchestrator: EligibleSpace

        Orchestrator->>NavDecider: select(eligibleSpace, instance, graph)
        NavDecider-->>Orchestrator: NavigationDecision

        alt PROCEED
            Orchestrator->>Governor: enforce(instance, node, context)
            Governor-->>Orchestrator: GovernanceResult
            Orchestrator->>Engine: executeNode(...)
            Orchestrator->>Tracer: record(decisionTrace)
        else WAIT
            Orchestrator->>Tracer: record(decisionTrace: WAIT)
        end

        Orchestrator-->>Client: OrchestrationStatus
    end

    rect rgb(252, 228, 236)
        Note over Client,Instance: External Event Handling
        Note right of Client: Events: DataChange, Approval,<br/>NodeCompleted, TimerExpired, etc.

        Client->>Orchestrator: signal(OrchestrationEvent.DataChange)

        Orchestrator->>Orchestrator: correlate event to instances

        loop For each affected instance
            Orchestrator->>CtxAssembler: addEvent(context, event)
            CtxAssembler-->>Orchestrator: RuntimeContext (with event)

            Orchestrator->>EligEval: reevaluateAfterEvent(instance, graph, context, eventType)

            Note over EligEval: Full reevaluation -<br/>context has changed

            EligEval->>NodeEval: evaluate nodes with event conditions
            EligEval->>EdgeEval: evaluate edges with event conditions
            EligEval-->>Orchestrator: EligibleSpace (new)

            Orchestrator->>NavDecider: select(eligibleSpace, ...)
            NavDecider-->>Orchestrator: NavigationDecision

            alt New actions available
                Orchestrator->>Governor: enforce(...)
                Orchestrator->>Engine: executeNode(...)
                Orchestrator->>Tracer: record(decisionTrace)
            end
        end
    end

    rect rgb(243, 229, 245)
        Note over Client,Instance: Process Completion
        Orchestrator->>Orchestrator: check if terminal node reached
        Orchestrator->>Orchestrator: check if no active nodes

        Orchestrator->>Instance: complete()
        Orchestrator->>Tracer: record(decisionTrace: type=NAVIGATION, outcome=COMPLETED)
        Orchestrator->>EventPub: publish(process.completed)
        Orchestrator-->>Client: OrchestrationStatus(isComplete=true)
    end

    rect rgb(255, 245, 238)
        Note over Client,Instance: Decision Trace Structure
        Note right of Tracer: DecisionTrace contains:<br/>- id, timestamp, instanceId<br/>- type: NAVIGATION|EXECUTION|WAIT|BLOCKED<br/>- ContextSnapshot (full context)<br/>- EvaluationSnapshot (nodes/edges evaluated)<br/>- DecisionSnapshot (selection + alternatives)<br/>- GovernanceSnapshot (all checks)<br/>- OutcomeSnapshot (result)
    end
