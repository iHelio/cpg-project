%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#e3f2fd'}}}%%
classDiagram
    direction TB

    %% Process Graph Aggregate
    class ProcessGraph {
        +ProcessGraphId id
        +String name
        +String description
        +int version
        +ProcessGraphStatus status
        +List~Node~ nodes
        +List~Edge~ edges
        +List~NodeId~ entryNodeIds
        +List~NodeId~ terminalNodeIds
        +Metadata metadata
        +findNode(NodeId) Optional~Node~
        +findEdge(EdgeId) Optional~Edge~
        +getOutboundEdges(NodeId) List~Edge~
        +getInboundEdges(NodeId) List~Edge~
        +validate() List~String~
    }

    class Node {
        +NodeId id
        +String name
        +String description
        +int version
        +Preconditions preconditions
        +List~PolicyGate~ policyGates
        +List~BusinessRule~ businessRules
        +Action action
        +EventConfig eventConfig
        +ExceptionRoutes exceptionRoutes
    }

    class Edge {
        +EdgeId id
        +String name
        +NodeId sourceNodeId
        +NodeId targetNodeId
        +GuardConditions guardConditions
        +ExecutionSemantics executionSemantics
        +Priority priority
        +EventTriggers eventTriggers
        +CompensationSemantics compensationSemantics
    }

    class Preconditions {
        +List~FeelExpression~ clientContextConditions
        +List~FeelExpression~ domainContextConditions
        +none()$ Preconditions
    }

    class PolicyGate {
        +String id
        +String name
        +PolicyType type
        +String dmnDecisionRef
        +String requiredOutcome
    }

    class BusinessRule {
        +String id
        +String name
        +String dmnDecisionRef
        +RuleCategory category
    }

    class Action {
        +ActionType type
        +String handlerRef
        +String description
        +ActionConfig config
    }

    class GuardConditions {
        +List~FeelExpression~ contextConditions
        +List~RuleOutcomeCondition~ ruleOutcomeConditions
        +List~PolicyOutcomeCondition~ policyOutcomeConditions
        +List~EventCondition~ eventConditions
        +hasConditions() boolean
        +alwaysTrue()$ GuardConditions
    }

    class ExecutionSemantics {
        +ExecutionType type
        +JoinType joinType
        +String compensationRef
        +sequential()$ ExecutionSemantics
        +parallel(JoinType)$ ExecutionSemantics
    }

    class FeelExpression {
        +String expression
        +String description
        +of(String)$ FeelExpression
    }

    %% Process Instance Aggregate
    class ProcessInstance {
        +ProcessInstanceId id
        +ProcessGraphId processGraphId
        +int processGraphVersion
        +String correlationId
        +Instant startedAt
        +Instant completedAt
        +ProcessInstanceStatus status
        +ExecutionContext context
        +List~NodeExecution~ nodeExecutions
        +Set~NodeId~ activeNodeIds
        +Set~EdgeId~ pendingEdgeIds
        +startNodeExecution(NodeId)
        +completeNodeExecution(NodeId, Object)
        +failNodeExecution(NodeId, String)
        +suspend()
        +resume()
        +complete()
    }

    class ExecutionContext {
        +Map clientContext
        +Map domainContext
        +Map accumulatedState
        +List~ReceivedEvent~ eventHistory
        +List~Obligation~ obligations
        +toFeelContext() Map
        +getValue(String) Object
        +withState(String, Object) ExecutionContext
        +withEvent(ReceivedEvent) ExecutionContext
    }

    class NodeExecution {
        +NodeId nodeId
        +Instant startedAt
        +Instant completedAt
        +NodeExecutionStatus status
        +Object result
        +String error
    }

    %% Events
    class ProcessEvent {
        +String eventId
        +String eventType
        +EventSource source
        +String correlationId
        +Instant timestamp
        +Map payload
        +nodeExecuted(...)$ ProcessEvent
        +processStarted(...)$ ProcessEvent
        +processCompleted(...)$ ProcessEvent
    }

    %% =========================================
    %% ORCHESTRATION DOMAIN
    %% =========================================

    class RuntimeContext {
        +Map clientContext
        +Map domainContext
        +Map entityState
        +OperationalContext operationalContext
        +List~ReceivedEvent~ receivedEvents
        +Instant assembledAt
        +toFeelContext() Map
        +getValue(String) Object
        +fromExecutionContext(ExecutionContext)$ RuntimeContext
        +empty()$ RuntimeContext
    }

    class EligibleSpace {
        +List~NodeEvaluation~ eligibleNodes
        +List~EdgeEvaluation~ traversableEdges
        +List~CandidateAction~ candidateActions
        +Instant evaluatedAt
        +isEmpty() boolean
        +hasExclusiveAction() boolean
        +getHighestPriority() Optional~CandidateAction~
        +empty()$ EligibleSpace
    }

    class CandidateAction {
        +NodeEvaluation nodeEvaluation
        +EdgeEvaluation edgeEvaluation
        +int priority
        +boolean isExclusive
        +forEntryNode(...)$ CandidateAction
        +forEdgeTraversal(...)$ CandidateAction
    }

    class NavigationDecision {
        +DecisionType type
        +List~NodeSelection~ selectedNodes
        +List~AlternativeConsidered~ alternatives
        +SelectionCriteria selectionCriteria
        +String selectionReason
        +EligibleSpace eligibleSpace
        +Instant decidedAt
        +proceed(...)$ NavigationDecision
        +wait(...)$ NavigationDecision
        +blocked(...)$ NavigationDecision
        +complete(...)$ NavigationDecision
    }

    class DecisionTrace {
        +DecisionTraceId id
        +Instant timestamp
        +ProcessInstanceId instanceId
        +DecisionType type
        +ContextSnapshot context
        +EvaluationSnapshot evaluation
        +DecisionSnapshot decision
        +GovernanceSnapshot governance
        +OutcomeSnapshot outcome
    }

    class GovernanceResult {
        +boolean approved
        +IdempotencyResult idempotencyResult
        +AuthorizationResult authorizationResult
        +PolicyGateResult policyGateResult
        +String rejectionReason
        +approved(...)$ GovernanceResult
        +rejected(...)$ GovernanceResult
    }

    class OrchestrationEvent {
        <<sealed interface>>
        +eventId() String
        +timestamp() Instant
        +correlationId() String
        +eventType() String
    }

    class DataChange {
        +String entityType
        +String entityId
        +ChangeType changeType
        +List~String~ changedFields
        +Map payload
    }

    class Approval {
        +ProcessInstanceId instanceId
        +NodeId nodeId
        +String approver
        +ApprovalDecision decision
        +String comments
    }

    class NodeCompleted {
        +ProcessInstanceId instanceId
        +NodeId nodeId
        +Object result
        +long durationMs
    }

    class NodeFailed {
        +ProcessInstanceId instanceId
        +NodeId nodeId
        +String errorType
        +String errorMessage
        +boolean retryable
    }

    class TimerExpired {
        +ProcessInstanceId instanceId
        +String timerId
        +TimerType timerType
        +Instant originalDeadline
    }

    %% Orchestration Enums
    class DecisionType {
        <<enumeration>>
        PROCEED
        WAIT
        BLOCKED
        COMPLETE
    }

    class SelectionCriteria {
        <<enumeration>>
        SINGLE_OPTION
        EXCLUSIVE
        HIGHEST_PRIORITY
        PARALLEL
        NO_OPTIONS
    }

    class OutcomeStatus {
        <<enumeration>>
        EXECUTED
        WAITING
        BLOCKED
        FAILED
        COMPLETED
    }

    %% Orchestration Ports
    class ProcessOrchestrator {
        <<interface>>
        +start(ProcessGraph, RuntimeContext) ProcessInstance
        +signal(OrchestrationEvent) void
        +suspend(ProcessInstanceId) void
        +resume(ProcessInstanceId) void
        +cancel(ProcessInstanceId) void
        +getStatus(ProcessInstanceId) OrchestrationStatus
    }

    class ExecutionGovernor {
        <<interface>>
        +checkIdempotency(...) IdempotencyResult
        +checkAuthorization(...) AuthorizationResult
        +checkPolicyGate(...) PolicyGateResult
        +enforce(...) GovernanceResult
    }

    class DecisionTracer {
        <<interface>>
        +record(DecisionTrace) void
        +findById(DecisionTraceId) Optional~DecisionTrace~
        +findByInstanceId(ProcessInstanceId) List~DecisionTrace~
    }

    class NodeSelector {
        <<interface>>
        +select(EligibleSpace, ProcessInstance, ProcessGraph) NavigationDecision
    }

    %% Enums
    class ProcessGraphStatus {
        <<enumeration>>
        DRAFT
        PUBLISHED
        DEPRECATED
        ARCHIVED
    }

    class ActionType {
        <<enumeration>>
        SYSTEM_INVOCATION
        HUMAN_TASK
        AGENT_ASSISTED
        DECISION
        NOTIFICATION
        WAIT
    }

    class ExecutionType {
        <<enumeration>>
        SEQUENTIAL
        PARALLEL
        COMPENSATING
    }

    class JoinType {
        <<enumeration>>
        ALL
        ANY
        N_OF_M
    }

    class PolicyType {
        <<enumeration>>
        COMPLIANCE
        STATUTORY
        REGULATORY
        ORGANIZATIONAL
    }

    class ProcessInstanceStatus {
        <<enumeration>>
        RUNNING
        SUSPENDED
        COMPLETED
        FAILED
        CANCELLED
    }

    %% Relationships
    ProcessGraph "1" *-- "0..*" Node : contains
    ProcessGraph "1" *-- "0..*" Edge : contains
    ProcessGraph --> ProcessGraphStatus

    Node "1" *-- "1" Preconditions
    Node "1" *-- "0..*" PolicyGate
    Node "1" *-- "0..*" BusinessRule
    Node "1" *-- "1" Action
    Preconditions "1" *-- "0..*" FeelExpression

    Edge "1" *-- "1" GuardConditions
    Edge "1" *-- "1" ExecutionSemantics
    Edge --> Node : sourceNodeId
    Edge --> Node : targetNodeId
    GuardConditions "1" *-- "0..*" FeelExpression

    Action --> ActionType
    ExecutionSemantics --> ExecutionType
    ExecutionSemantics --> JoinType
    PolicyGate --> PolicyType

    ProcessInstance --> ProcessGraph : references
    ProcessInstance "1" *-- "1" ExecutionContext
    ProcessInstance "1" *-- "0..*" NodeExecution
    ProcessInstance --> ProcessInstanceStatus

    ExecutionContext "1" *-- "0..*" ProcessEvent : eventHistory

    %% Orchestration Relationships
    RuntimeContext --> ExecutionContext : converts from
    EligibleSpace "1" *-- "0..*" CandidateAction
    NavigationDecision --> DecisionType
    NavigationDecision --> SelectionCriteria
    NavigationDecision --> EligibleSpace
    DecisionTrace --> GovernanceResult : governance
    DecisionTrace --> DecisionType
    GovernanceResult --> ProcessInstance

    OrchestrationEvent <|-- DataChange
    OrchestrationEvent <|-- Approval
    OrchestrationEvent <|-- NodeCompleted
    OrchestrationEvent <|-- NodeFailed
    OrchestrationEvent <|-- TimerExpired

    ProcessOrchestrator --> ProcessInstance : manages
    ProcessOrchestrator --> OrchestrationEvent : receives
    ProcessOrchestrator --> DecisionTrace : produces
    ExecutionGovernor --> GovernanceResult : returns
    DecisionTracer --> DecisionTrace : persists
    NodeSelector --> NavigationDecision : returns
    NodeSelector --> EligibleSpace : selects from
